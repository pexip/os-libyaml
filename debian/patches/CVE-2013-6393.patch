Description: fix denial of service and possible code execution via
 large yaml documents
Origin: upstream, https://bitbucket.org/xi/libyaml/commits/1d73f004f49e6962cf936da98aecf0aec95c4c50
Origin: upstream, https://bitbucket.org/xi/libyaml/commits/b77d42277c32b58a114a0fa0968038a4b0ab24f4
Origin: upstream, https://bitbucket.org/xi/libyaml/commits/f859ed1eb757a3562b98a28a8ce69274bfd4b3f2
Origin: upstream, https://bitbucket.org/xi/libyaml/commits/0df2fb962294f3a6df1450a3e08c6a0f74f9078c
Origin: upstream, https://bitbucket.org/xi/libyaml/commits/af3599437a87162554787c52d8b16eab553f537b
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/libyaml/+bug/1279805
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/libyaml/+bug/1276156
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=737076
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=738587
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1033990

Index: libyaml-0.1.4/src/loader.c
===================================================================
--- libyaml-0.1.4.orig/src/loader.c	2011-05-29 01:55:42.000000000 -0400
+++ libyaml-0.1.4/src/loader.c	2014-02-13 08:32:26.228856720 -0500
@@ -286,6 +286,8 @@
     int index;
     yaml_char_t *tag = first_event->data.scalar.tag;
 
+    if (!STACK_LIMIT(parser, parser->document->nodes, INT_MAX-1)) goto error;
+
     if (!tag || strcmp((char *)tag, "!") == 0) {
         yaml_free(tag);
         tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_SCALAR_TAG);
@@ -329,6 +331,8 @@
     int index, item_index;
     yaml_char_t *tag = first_event->data.sequence_start.tag;
 
+    if (!STACK_LIMIT(parser, parser->document->nodes, INT_MAX-1)) goto error;
+
     if (!tag || strcmp((char *)tag, "!") == 0) {
         yaml_free(tag);
         tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG);
@@ -351,6 +355,9 @@
     if (!yaml_parser_parse(parser, &event)) return 0;
 
     while (event.type != YAML_SEQUENCE_END_EVENT) {
+        if (!STACK_LIMIT(parser,
+                    parser->document->nodes.start[index-1].data.sequence.items,
+                    INT_MAX-1)) return 0;
         item_index = yaml_parser_load_node(parser, &event);
         if (!item_index) return 0;
         if (!PUSH(parser,
@@ -387,6 +394,8 @@
     yaml_node_pair_t pair;
     yaml_char_t *tag = first_event->data.mapping_start.tag;
 
+    if (!STACK_LIMIT(parser, parser->document->nodes, INT_MAX-1)) goto error;
+
     if (!tag || strcmp((char *)tag, "!") == 0) {
         yaml_free(tag);
         tag = yaml_strdup((yaml_char_t *)YAML_DEFAULT_MAPPING_TAG);
@@ -409,6 +418,9 @@
     if (!yaml_parser_parse(parser, &event)) return 0;
 
     while (event.type != YAML_MAPPING_END_EVENT) {
+        if (!STACK_LIMIT(parser,
+                    parser->document->nodes.start[index-1].data.mapping.pairs,
+                    INT_MAX-1)) return 0;
         pair.key = yaml_parser_load_node(parser, &event);
         if (!pair.key) return 0;
         if (!yaml_parser_parse(parser, &event)) return 0;
Index: libyaml-0.1.4/src/reader.c
===================================================================
--- libyaml-0.1.4.orig/src/reader.c	2011-05-29 01:55:42.000000000 -0400
+++ libyaml-0.1.4/src/reader.c	2014-02-13 08:32:30.716856793 -0500
@@ -460,6 +460,10 @@
 
     }
 
+    if (parser->offset >= PTRDIFF_MAX)
+        return yaml_parser_set_reader_error(parser, "input is too long",
+                PTRDIFF_MAX, -1);
+
     return 1;
 }
 
Index: libyaml-0.1.4/src/scanner.c
===================================================================
--- libyaml-0.1.4.orig/src/scanner.c	2014-02-13 08:31:50.000000000 -0500
+++ libyaml-0.1.4/src/scanner.c	2014-02-13 08:32:32.836856827 -0500
@@ -615,11 +615,11 @@
  */
 
 static int
-yaml_parser_roll_indent(yaml_parser_t *parser, int column,
-        int number, yaml_token_type_t type, yaml_mark_t mark);
+yaml_parser_roll_indent(yaml_parser_t *parser, ptrdiff_t column,
+        ptrdiff_t number, yaml_token_type_t type, yaml_mark_t mark);
 
 static int
-yaml_parser_unroll_indent(yaml_parser_t *parser, int column);
+yaml_parser_unroll_indent(yaml_parser_t *parser, ptrdiff_t column);
 
 /*
  * Token fetchers.
@@ -1103,7 +1103,7 @@
      */
 
     int required = (!parser->flow_level
-            && parser->indent == (int)parser->mark.column);
+            && parser->indent == (ptrdiff_t)parser->mark.column);
 
     /*
      * A simple key is required only when it is the first token in the current
@@ -1176,6 +1176,11 @@
 
     /* Increase the flow level. */
 
+    if (parser->flow_level == INT_MAX) {
+        parser->error = YAML_MEMORY_ERROR;
+        return 0;
+    }
+
     parser->flow_level++;
 
     return 1;
@@ -1206,8 +1211,8 @@
  */
 
 static int
-yaml_parser_roll_indent(yaml_parser_t *parser, int column,
-        int number, yaml_token_type_t type, yaml_mark_t mark)
+yaml_parser_roll_indent(yaml_parser_t *parser, ptrdiff_t column,
+        ptrdiff_t number, yaml_token_type_t type, yaml_mark_t mark)
 {
     yaml_token_t token;
 
@@ -1226,6 +1231,11 @@
         if (!PUSH(parser, parser->indents, parser->indent))
             return 0;
 
+        if (column > INT_MAX) {
+            parser->error = YAML_MEMORY_ERROR;
+            return 0;
+        }
+
         parser->indent = column;
 
         /* Create a token and insert it into the queue. */
@@ -1254,7 +1264,7 @@
 
 
 static int
-yaml_parser_unroll_indent(yaml_parser_t *parser, int column)
+yaml_parser_unroll_indent(yaml_parser_t *parser, ptrdiff_t column)
 {
     yaml_token_t token;
 
@@ -2574,7 +2584,7 @@
 
     /* Resize the string to include the head. */
 
-    while (string.end - string.start <= (int)length) {
+    while ((size_t)(string.end - string.start) <= length) {
         if (!yaml_string_extend(&string.start, &string.pointer, &string.end)) {
             parser->error = YAML_MEMORY_ERROR;
             goto error;
Index: libyaml-0.1.4/src/yaml_private.h
===================================================================
--- libyaml-0.1.4.orig/src/yaml_private.h	2011-05-29 01:55:42.000000000 -0400
+++ libyaml-0.1.4/src/yaml_private.h	2014-02-13 08:32:30.716856793 -0500
@@ -7,6 +7,8 @@
 
 #include <assert.h>
 #include <limits.h>
+#include <stddef.h>
+#include <stdint.h>
 
 /*
  * Memory management.
@@ -421,6 +423,12 @@
 #define STACK_EMPTY(context,stack)                                              \
     ((stack).start == (stack).top)
 
+#define STACK_LIMIT(context,stack,size)                                         \
+    ((stack).top - (stack).start < (size) ?                                     \
+        1 :                                                                     \
+        ((context)->error = YAML_MEMORY_ERROR,                                  \
+         0))
+
 #define PUSH(context,stack,value)                                               \
     (((stack).top != (stack).end                                                \
       || yaml_stack_extend((void **)&(stack).start,                             \
